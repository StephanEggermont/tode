TDDirectoryNode{#name:'home',#contents:{'cypress':TDDirectoryNode{#name:'cypress',#contents:{'gitRepo':TDObjectGatewayNode{#name:'gitRepo',#contents:'| repo |\nrepo := (self topez lookup: \'repo\') dotSelfObject.\nrepo directory'},'todo':TDTxtLeafNode{#name:'todo',#contents:Text{#string:'',#runs:RunArray{#runs:[],#values:[],#lastIndex:nil,#lastRun:nil,#lastOffset:nil}}},'analysis':TDTxtLeafNode{#name:'analysis',#contents:Text{#string:'unescapePercents and asCypressPropertyObject are very suspicious...',#runs:RunArray{#runs:[67],#values:[[]],#lastIndex:1,#lastRun:1,#lastOffset:0}}},'repo':TDObjectGatewayNode{#name:'repo',#contents:'(TDMonticelloRepository\n  fromDescription:\n    \'filetree:///export/galbadia1/users/dhenrich/CypressReferenceImplementation\')\n  repository'},'commit':TDTopezLeafNode{#name:'commit',#contents:'/home/bin/commitCypress Cypress @cypressRepo @commitMessage'},'commitMessage':TDTxtLeafNode{#name:'commitMessage',#contents:Text{#string:'move methods to GLASS base:\r\r  Url class>>absoluteFromText:\r  Url class>>schemeName\r  Url class>>urlClassForScheme:',#runs:RunArray{#runs:[31,28,3,53],#values:[[],[TextColor{#color:Color{#rgb:1072693248}}],[],[TextColor{#color:@27}]],#lastIndex:85,#lastRun:4,#lastOffset:22}}},'load':TDTopezLeafNode{#name:'load',#contents:'/home/bin/load Cypress ALL'},'status':TDTxtLeafNode{#name:'status',#contents:'commit 16ae364603b31c3360e068a05f3d716e4a210961\nAuthor: Dale Henrichs <dale.henrichs@gemtalksystems.com>\nDate:   Sat Aug 31 15:16:51 2013 -0700\n\n    move methods to GLASS base:\n    \n      Url class>>absoluteFromText:\n      Url class>>schemeName\n      Url class>>urlClassForScheme:\n'},'diff':TDTopezLeafNode{#name:'diff',#contents:'cym diff Cypress @cypressRepo'},'browse':TDTopezLeafNode{#name:'browse',#contents:'browse project Cypress'},'filter':TDSmalltalkLeafNode{#name:'filter',#contents:'[ :definition | \ndefinition configurationOf\n  ifNil: [ false ]\n  ifNotNil: [ :configurationDef | configurationDef configurationName = \'Cypress\' ] ]'},'x':TDSmalltalkLeafNode{#name:'x',#contents:'| repo |\nrepo := CypressFileSystemRepository\n  onUrl: \'cypressft:/export/galbadia1/users/rsargent/git/gitRepos/\' asUrl\n  alias: \'Cypress\'.\nrepo gemStoneFileoutsEnabled: true.\nrepo'},'cypressRepo':TDObjectGatewayNode{#name:'cypressRepo',#contents:'| repo |\nrepo := CypressFileSystemRepository\n  onUrl:\n    \'cypressft:/export/galbadia1/users/dhenrich/CypressReferenceImplementation/\'\n      asUrl\n  alias: \'Cypress\'.\nrepo gemStoneFileoutsEnabled: true.\nrepo'}}},'tode':TDDirectoryNode{#name:'tode',#contents:{'gitRepo':TDObjectGatewayNode{#name:'gitRepo',#contents:'| repo |\nrepo := (self topez lookup: \'repo\') dotSelfObject.\nrepo directory containingDirectory'},'todo':TDTxtLeafNode{#name:'todo',#contents:Text{#string:'1. bedit should take an edit script object as arg...pick an editing language...vi/awk/sed ... maybe just pass the source into awk/sed ...\r2. merge tool badly needed!\r3. object log/debugger link\r4. opening the globals on far right side (option for wider displays)\r5. consider method protocol windows on left?\r6. mv /home/test to /tmp/test/randomNum dir?\r7. isolate window sizing from sesssion descriptions on client\r8. finish implementation of `find symbolists` and `find symbolList` using TDSymbolDictionaryDefinition and TDSymbolListList',#runs:RunArray{#runs:[489,28,21],#values:[[],[TextColor{#color:Color{#rgb:536871424}}],[]],#lastIndex:518,#lastRun:3,#lastOffset:0}}},'tools':TDTopezLeafNode{#name:'tools',#contents:'browse hierarchy TDAbstractDevTool'},'repo':TDObjectGatewayNode{#name:'repo',#contents:'(TDMonticelloRepository fromDescription: \'filetree:///opt/git/tode/repository\')\n  repository'},'load':TDTopezLeafNode{#name:'load',#contents:'/home/bin/load Tode `GemStone Dev` Topez-Server-CypressTools\r./initTools'},'status':TDTxtLeafNode{#name:'status',#contents:'commit b22591c4f3ff854f5273959310f6ed235344d6ee\nAuthor: Dale Henrichs <dale.henrichs@gemtalksystems.com>\nDate:   Sat Aug 31 15:05:56 2013 -0700\n\n    tweak TDCypressTool>>cypDiffPackage:to:on:\n'},'initTools':TDSmalltalkLeafNode{#name:'initTools',#contents:'TDStandardTool initializeTools'},'commitMessage':TDTxtLeafNode{#name:'commitMessage',#contents:Text{#string:'tweak TDCypressTool>>cypDiffPackage:to:on:',#runs:RunArray{#runs:[6,36],#values:[[TextEmphasis{#emphasisCode:0,#setMode:true},TextEmphasis{#emphasisCode:1,#setMode:true}],[]],#lastIndex:7,#lastRun:2,#lastOffset:0}}},'commit':TDTopezLeafNode{#name:'commit',#contents:'/home/bin/commit Tode @commitMessage'},'nodes':TDTopezLeafNode{#name:'nodes',#contents:'browse hierarchy TDNode'},'scratch':TDTxtLeafNode{#name:'scratch',#contents:Text{#string:'    GsIndexSpec new\r      unicodeIndex: \'each.#car.color\' \r        collator: IcuCollator default;\r      rcUnicodeIndex: \'each.firstName\' \r        collator: (IcuCollator forLocaleNamed: \'en_GB\')\r        requireUnicodeStrings: true;\r      createIndexesOn: myEmployees.\r',#runs:RunArray{#runs:[267],#values:[[TextColor{#color:Color{#rgb:0}}]],#lastIndex:232,#lastRun:1,#lastOffset:231}}},'x':TDTopezLeafNode{#name:'x',#contents:'bedit instance TDBatchEditTool `<source-regex> <replacement-string>` xxx'},'diff':TDTopezLeafNode{#name:'diff',#contents:'mm diff Tode'},'browse':TDTopezLeafNode{#name:'browse',#contents:'browse project Tode'},'filter':TDSmalltalkLeafNode{#name:'filter',#contents:'[ :definition | \ndefinition configurationOf\n  ifNil: [ false ]\n  ifNotNil: [ :configurationDef | configurationDef configurationName = \'Tode\' ] ]'},'merging':TDTopezLeafNode{#name:'merging',#contents:'browse category Monticello-Merging'}}},'petit':TDDirectoryNode{#name:'petit',#contents:{'gitRepo':TDObjectGatewayNode{#name:'gitRepo',#contents:'| repo |\rrepo := (self topez lookup: \'repo\') dotSelfObject.\rrepo directory containingDirectory'},'repo':TDObjectGatewayNode{#name:'repo',#contents:'(TDMonticelloRepository fromDescription: \'filetree:///opt/git/PetitParser/packages\') repository'},'commit':TDTopezLeafNode{#name:'commit',#contents:'/home/bin/commitCypress PetitParser @cypressRepo @commitMessage'},'commitMessage':TDTxtLeafNode{#name:'commitMessage',#contents:Text{#string:'port PetitParser and PetitSmalltalk to GLASS:\r\r  move Character>>sameAs: to PetitGemStone-Extensions package',#runs:RunArray{#runs:[54,54],#values:[[],[TextColor{#color:Color{#rgb:1072693248}}]],#lastIndex:55,#lastRun:2,#lastOffset:0}}},'load':TDTopezLeafNode{#name:'load',#contents:'/home/bin/load PetitParser ALL'},'status':TDTxtLeafNode{#name:'status',#contents:'commit 036cfc826aaef9df201c844f6db109a7763d4ee5\nAuthor: Dale Henrichs <dale.henrichs@gemtalksystems.com>\nDate:   Sat Aug 31 16:11:02 2013 -0700\n\n    PetitGemStone-Extensions not loaded into GLASS\n'},'diff':TDTopezLeafNode{#name:'diff',#contents:'cym diff PetitParser @cypressRepo'},'lukas':TDObjectGatewayNode{#name:'lukas',#contents:'(TDMonticelloRepository fromDescription: \'http://source.lukas-renggli.ch/petit\')\n  repository'},'browse':TDScriptLeafNode{#name:'browse',#contents:'[ :topez :objIn :tokens :windowId | \n| findTool defs |\nfindTool := topez toolInstanceFor: \'find\'.\ndefs := OrderedCollection new.\n#(\'PetitParser-cypress\' \'PetitTests\' \'PetitSmalltalk\')\n  do: [ :packageName | defs addAll: (findTool findPackageDefinitions: packageName) ].\n(topez toolInstanceFor: \'browse\') browseClasses: defs ]'},'cypressRepo':TDObjectGatewayNode{#name:'cypressRepo',#contents:'| repo |\nrepo := CypressFileSystemRepository\n  onUrl: \'cypressft:/opt/git/PetitParser/packages/\' asUrl\n  alias: \'Petit Parser\'.\nrepo gemStoneFileoutsEnabled: true.\nrepo'}}},'indexing':TDDirectoryNode{#name:'indexing',#contents:{'commit':TDTopezLeafNode{#name:'commit',#contents:'/home/bin/commit Indexing @commitMessage'},'reset':TDScriptLeafNode{#name:'reset',#contents:'[ :topez :objIn :tokens :windowId | \n| resetAll indexManager |\n\"./reset [true|false]\"\nresetAll := false.\ntokens size > 1\n  ifTrue: [ resetAll := (tokens at: 2) = \'true\' ].\nIXQueryTestResource reset.\nindexManager := IndexManager current.\nresetAll\n  ifTrue: [ \n    indexManager\n      removeAllIndexes;\n      resetAllIndexes ].\r\tIXQueryTestResource current. \"force creation of new resources\"\nindexManager ]'},'gitRepo':TDObjectGatewayNode{#name:'gitRepo',#contents:'| repo |\rrepo := (self topez lookup: \'repo\') dotSelfObject.\rrepo directory containingDirectory'},'combineGenerator':TDSmalltalkLeafNode{#name:'combineGenerator',#contents:'| formatter combineWith negateWith |\ncombineWith := \'combineWith: aGsQueryOptions \'.\nnegateWith := \'negateWith: aGsQueryOptions \'.\n#(#\'applyDeMorgansLaws\' #\'cacheQueryResult\' #\'consolidateEnumerablePredicates\' #\'consolidateRangePredicates\' #\'normalizePredicates\' #\'removeRedundantPredicates\' #\'reorderPredicates\' #\'transformCommonPaths\')\n  do: [ :ivSym | \n    | iv |\n    iv := ivSym asString.\n    combineWith := combineWith , \' self \' , iv\n      , \' ifTrue: [ aGsQueryOptions set\' , iv capitalized , \' ]. \'.\n    negateWith := negateWith , \' self \' , iv\n      , \' ifTrue: [ aGsQueryOptions clear\' , iv capitalized , \' ]. \' ].\ncombineWith := combineWith , \' ^ aGsQueryOptions\'.\nnegateWith := negateWith , \' ^ aGsQueryOptions\'.\nformatter := [ :aString | \n(RBParser parseMethod: aString asString onError: [ :err :pos | ^ aString ])\n  formattedCode ].\nGsQueryOptions\n  compile: (formatter value: combineWith);\n  compile: (formatter value: negateWith)'},'queryOptions':TDSmalltalkLeafNode{#name:'queryOptions',#contents:'#(#\'applyDeMorgansLaws\' #\'cacheQueryResult\' #\'consolidateEnumerablePredicates\' #\'consolidateRangePredicates\' #\'normalizePredicates\' #\'removeRedundantPredicates\' #\'reorderPredicates\' #\'transformCommonPaths\')\n  do: [ :ivSym | \n    | iv formatter |\n    iv := ivSym asString.\n    formatter := [ :aString | \n    (RBParser parseMethod: aString asString onError: [ :err :pos | ^ aString ])\n      formattedCode ].\n    GsQueryOptions\n      compile:\n          (formatter value: iv , \' \' , iv , \' ifNil: [ \' , iv , \' := false ]. ^ \' , iv);\n      compile: (formatter value: iv , \': aBoolean \' , iv , \' := aBoolean\');\n      compile: (formatter value: \'set\' , iv capitalized , \' \' , iv , \' := true\');\n      compile:\n          (formatter value: \'clear\' , iv capitalized , \' \' , iv , \' := false\') ]'},'patchRestrictedClasses':TDSmalltalkLeafNode{#name:'patchRestrictedClasses',#contents:'| cls index set |\ncls := GsPackagePolicy.\nindex := cls class allInstVarNames indexOfIdentical: #\'restrictedClasses\'.\nset := cls instVarAt: index.\nset removeAll: set.\nfalse\n  ifTrue: [ SetValuedPathTerm category: \'Index-Family\' ]'},'notes':TDTxtLeafNode{#name:'notes',#contents:Text{#string:'pg. 14:\r  \"Note that \'each\' is a required initial term for all indexes created using \r  GsIndexSpec; this differs from traditional indexed paths, which had an \r  implicit first term.\"\r\r  The \'each\' is now optional.\r---------\r  \"GsIndexSpecifications can be concatenated using the #, operator\"\r\r  I hadn\'t actually intended this, but I doesn\'t sound like a bad idea:). The comma\r  was only intended for use with GsIndexOptions.\r---------\rpg. 23:\r  \"homogenous\" should be \"homogeneous\"\r---------\r',#runs:RunArray{#runs:[10,484],#values:[[],[TextColor{#color:Color{#rgb:0}}]],#lastIndex:485,#lastRun:2,#lastOffset:474}}},'indexManager':TDObjectGatewayNode{#name:'indexManager',#contents:'IndexManager current'},'load':TDTopezLeafNode{#name:'load',#contents:'/home/bin/load Indexing default'},'status':TDTxtLeafNode{#name:'status',#contents:'commit 740425ea224058c1560934467eebd5d5fc64b93d\nAuthor: Dale Henrichs <dale.henrichs@gemtalksystems.com>\nDate:   Thu Aug 29 21:14:25 2013 -0700\n\n    move UnorderedCollection>>_evaluatorFor:isRangeEqualityOperation: back to GemStone-Indexing-Extensions where it belongs\n'},'diff':TDTopezLeafNode{#name:'diff',#contents:'mm diff Indexing'},'spec':TDTxtLeafNode{#name:'spec',#contents:Text{#string:'New Indexing Features for GemStone Smalltalk 64bit v3.2\r                                                          [Dale Henrichs: v0.10]\r\r-------------------------------------------------------------------------------\rOVERVIEW\r-------------------------------------------------------------------------------\r\rModification Tracking\r------------------------\r\r  To implement many of the indexing features it is necessary to validate that\r  modification tracking is functional for all objects, so I think it is about\r  time to add test coverage for modification tracking independent of the \r  indexing subsystem and explicitly document any exceptions. In a nutshell this\r  involves ensuring that we have proper support for modification tracking \r  (i.e., add test coverage and correct deficiencies) for:\r\r    - dynamic instance variables,\r    - named and indexable portion of all pointer and byte objects\r    - all subclasses of UnorderedCollections\r    - all subclasses of SequencableCollections\r    - all subclasses of ByteArray\r\r  After a brief review of the C code, Allen has determined that the vast \r  majority of cases are already covered for modification tracking, with the \r  most notable exceptions being a handful of special purpose Array \r  primitives. \r\r  I have a basic modification test suite tucked away somewhere that can be \r  used as the basis for the initial set of tests.\r\rNew Index Creation API\r------------------------\r\r  The class GsIndexSpec maintains a collection of instances of subclasses \r  of AbstractIndexSpecifications. The instances of AbstractIndexSpecification\r  are created using GsIndexSpec methods, not directly. \r\r  To create an index on an nsc, one first creates an instance of GsIndexSpec \r  with one or more index specifications:\r\r    spec := GsIndexSpec new\r      equalityIndex: \'each.age\' lastElementClass: SmallInteger;\r      equalityIndex: \'each.father.firstName\' lastElementClass: String;\r      yourself.\r\r  Note that the reserved variable \"each\" is required in every index path.  \r  Using the old API, it was correct to create an index on empty string, \'\'. \r  Using the new API, the equivalent would be \'each\'.\r\r  One then uses the spec to create the indexes on an nsc:\r\r    spec createIndexesOn: nsc.\r\r  The spec is not associated with any specific nsc, so an index spec can be \r  used to create indexes on a number of collections:\r\r    spec createIndexesOn: nsc.\r    spec createIndexesOn: anotherNsc.\r\r  The spec may be used to remove a set of indexes from a collection:\r\r    spec removeIndexesFrom: nsc.\r\r  One can get also get an index spec for an nsc with the #indexSpec message:\r\r    spec := nsc indexSpec.\r\r  Printing an index spec for an nsc provides a useful \"index report\":\r\r    \'GsIndexSpec new\r      equalityIndex: \'\'each.age\'\' lastElementClass: SmallInteger;\r      equalityIndex: \'\'each.father.firstName\'\' lastElementClass: String;\r      yourself\'\r\r  You can also use the index spec for rebuilding indexes:\r\r    spec := nsc indexSpec.\r    nsc removeAllIndexes.\r    spec createIndexesOn: nsc.\r    \r  Here is the full list of index creation messages in GsIndexSpec:\r\r    equalityIndex:lastElementClass:\r    equalityIndex:lastElementClass:options:\r    identityIndex:\r    identityIndex:options:\r    unicodeIndex:collator:\r    unicodeIndex:collator:options:\r\rIndex Creation Options\r------------------------\r\rThere are three different independent options available:\r\r  reducedConflict\r  requirePathTerms\r  requireUnicodeStrings (meaningful for unicode indexes only)\r\rAny combination of the above options may be specified as  \rarguments to the options keyword. Use the #, message to\rcombine multiple options:\r\r  GsIndexOptions requirePathTerms , GsIndexOptions reducedConflict\r \rCreating a reduced conflict index:\r\r GsIndexSpec new\r  equalityIndex: \'each.sons.*.numberOfChildren\'\r    lastElementClass: SmallInteger\r    options: GsIndexOptions reducedConflict;\r  unicodeIndex: \'each.lastName\'\r    collator: (IcuCollator forLocaleNamed: \'en_GB\')\r    options: GsIndexOptions reducedConflict;\r  yourself.\r\rExamples of the other options:\r\r GsIndexSpec new\r  equalityIndex: \'each.sons.*.numberOfChildren\'\r    lastElementClass: SmallInteger\r    options: GsIndexOptions requirePathTerms , \r               GsIndexOptions reducedConflict;\r  unicodeIndex: \'each.lastName\'\r    collator: (IcuCollator forLocaleNamed: \'en_GB\')\r    options:\r      GsIndexOptions requirePathTerms , \r        GsIndexOptions requireUnicodeStrings;\r  yourself\r\rNew Query API\r------------------------\r\r  The class GsQuery is used for defining and executing queries.\r  The instance of GsQuery includes a formula, which is an instance of \r  GsQueryFormula, which can be re-used in other queries.  \r  A GsQueryFormula combines predicates using operators.\r\r  The following expression:\r\r    (GsQuery fromString: \'each.age <= 18\') executeOn: nsc.\r\r  is equivalent to the following old-style select block expression:\r\r    nsc select: {:each | each.age <= 18}.\r\r  Multiple predicates are supported:\r\r    GsQuery fromString: \'(each.age <= 18) & (each.firstName = \'\'Dale\'\')\'.\r\r  The OR operator ($|) is supported, so queries like the following can be \r  executed:\r\r    GsQuery fromString: \r      \'(each.firstName = \'\'Dale\'\') & ((each.age <= 18) | (each.age > 55))\'.\r\r  The #not message is also supported. In the simple case one may write \r  queries of the form:\r\r    GsQuery fromString: \r      \'(each.firstName = \'\'Dale\'\') not\'.\r\r  The system will transform queries containing #not to an equivalent form \r  of the query without the #not, using De Morgan\'s Laws, so that optimized \r  queries may still be performed in the presence of a #not. In the above \r  simple case the query is transformed to: \r\r    GsQuery fromString: \r      \'(each.firstName ~= \'\'Dale\'\')\'.\r\r  A slightly more complex query:\r\r     GsQuery fromString: \r      \'(each.firstName = \'\'Dale\'\') & ((each.age <= 18) | (each.age > 55)) not\'.\r\r  would be transformed to the following:\r\r     GsQuery fromString: \r      \'(each.firstName ~= \'\'Dale\'\') | ((each.age > 18) & (each.age <= 55))\'.\r \r  and so on.\r\r  One may directly write range queries of the form:\r\r    GsQuery fromString: \'18 <= each.age < 50\'.\r\r  If one happens to write an `invalid` range query:\r\r    GsQuery fromString: \'18 > each.age < 50\'.\r\r  The system correctly recognizes that fact and the query is converted to a \r  valid form.\r\r    GsQuery fromString: \'(18 > each.age) & (each.age < 50)\'.\r\r  This conversion occurs during GsQuery creation, before the optimize step.\r\r  Query Variables\r  ---------------\r\r  One may write queries using variables, so the above query could have been\r  written as:\r\r    GsQuery fromString: \'min <= each.age < max\'.\r\r  Variable values are bound to the query variables using the #bind:to: \r  message:\r\r    (GsQuery fromString: \'min <= each.age < max\')\r      bind: \'min\' to: 18;\r      bind: \'max\' to: 50;\r      executeOn: nsc.\r\r  Basic Query Functions\r  ---------------------\r\r  #executeOn: causes a query result to be calculated for the given `nsc`.\r  #executeOn: is a convenience method for the following standard sequence:\r\r    (GsQuery fromString: \'(each.firstName ~= \'\'Dale\'\')\')\r      on: nsc;\r      optimize;\r      execute.\r\r  The #on: message binds an `nsc` to the query and evaluators are bound to\r  each predicate in the query formula. After binding an `nsc`, the message \r  #hasIndexEvaluators can be used to determine if each of the predicates\r  is using an index on the nsc.\r\r  The #optimize message performs a number of optimizations on the query \r  formula. A query may be sent the #optimize message before being bound to \r  an nsc using the #on: message, however some optimizations cannot be \r  performed without an bound nsc. Similarly, a query may be sent the #\r  optimize message before variable values are bound, but some \r  optimizations may not be performed.\r\r  Here\'s a list of the optimizations performed:\r\r    - convert clauses modified by `not` using De Morgan\'s Laws\r\r          (each.firstName = \'Dale\') not\r\r        becomes:\r\r          (each.firstName ~= \'Dale\')\r\r    - convert predicates with common path-path operands to an equivalent\r      constant predicate\r\r          (each.firstName = each.firstName) \r\r        becomes:\r\r          (true)\r\r    - replace constant-path predicates with equivalent path-constant \r      predicates\r\r          (19 > each.age) \r\r        becomes:\r\r          (each.age < 19)\r\r    - eliminate redundant predicates. i.e., predicates that fall within range\r      of other predicates\r\r          (each.age < 19) & (each.age < 4)\r\r        becomes:\r\r          (each.age < 4)\r\r        Note that elimination of redundant predicates requires that any \r        variables in the query be bound to values.\r\r    - convert 2 path-constant predicates into a range predicate when possible\r\r          (each.age > 4) & (each.age < 19)\r\r        becomes:\r\r          (4 < each.age < 19)\r\r        Note that elimination of redundant predicates requires that any \r        variables in the query be bound to values.\r\r    - reorder predicates based on following ordering rules:\r        constant predicates\r        indexed predicates\r        identity comparison predicates\r        equality comparison predicates\r        all others\r\r          (each.age <= 21) & (each.gender == #male) & \r          (each.name = \'Dale\') & (each.father = each.father)\r\r        assuming each.name is indexed and each.age is not indexed, becomes:\r\r          (true) & (each.name = \'Dale\') & \r          (each.gender == #male) & (each.age <= 21)\r\r        Note that some of the reordering optimizations require an nsc and \r        any variables to be bound to the query.\r\r    - consolidate path-constant predicates to single enumerated predicate\r      if an index exists that has an enumerated path term and predicates\r      using the enumerated path  term can be combined into a single \r      predicate\r\r          (each.firstName = \'Martin\') | (each.lastName = \'Martin\')\r\r        becomes:\r\r          (each.firstName|lastName = \'Martin\')\r\r        Note that some of the consolidation optimizations require an nsc and \r        any variables to be bound to the query.\r\r  Original Formula\r  ----------------\r\r  The #optimize message may transform the query formula beyond recognition. If\r  one wants to review and understand the optimizations performed, one must be\r  able to view the original formula used to create the query.\r\r  The GsQuery instance records the original formula and makes it available via\r  the #originalFormula message. \r\r  When the original formula is recorded all of the bound state is removed\r  (nsc, bound variable values, etc.) so that stale values are not kept alive.\r  \r  If one wants to create a new query from an original formula do the following:\r\r    query := GsQuery \r      fromString: \'(each.numberOfChildren < 4) & (2 < each.numberOfChildren)\'.\r    query \r      one: nsc;\r      optimize.\r    originalFormula := query originalFormula.\r    originalQuery := GsQuery fromFormula: originalFormula.\r\r  Query Execution\r  ---------------\r\r  The #execute message causes the query result to be calculated. Note that\r  I have chosen not to use #select, because we are not using a block to \r  perform the query. Using #select would tend to imply that #reject and \r  #detect would be supported.\r\r  Reject functionality can be achieved by forming the query using `not`:\r\r    (each.firstName = \'Dale\') not\r\r  or by `negating` the query formula itself:\r\r    query := GsQuery fromString: \'(each.firstName = \'\'Dale\'\')\'.\r    negatedQuery := GsQuery fromFormula: query formula not. \r    rejectEquivalent := negatedQuery executeOn: nsc.\r\r  Detect functionality can be achieved by using #do: or #do:for: and \r  exiting the block early:\r\r    (GsQuery fromString: \'(each.firstName = \'\'Dale\'\')\')\r      do: [:each | ^each]\r      on: nsc\r\r  where the #do:on: message is a shortcut for the following sequence:\r\r    (GsQuery fromString: \'(each.firstName = \'\'Dale\'\')\')\r      on: nsc;\r      optimize;\r      do: [:each | ^each]\r\r  Detect:ifNone: functionality can be achieved by using #do:ifEmpty: or \r  #do:ifEmpty:for: as follows:\r\r    (GsQuery fromString: \'(each.firstName = \'\'Dale\'\')\')\r      do: [:each | ^each]\r      ifEmpty: [self error: \'No elements matched the query\' ]\r      on: nsc\r\r  Query Streams\r  -------------\r\r  To stream over the results of query one may use #readStream, \r  #readStreamOn:, #reversedReadStream, and #reversedReadStreamOn:. For\r  example:\r\r    stream := (GsQuery fromString: \'(each.firstName = \'\'Dale\'\')\')\r      readStreamOn: nsc.\r    [ stream atEnd ] whileFalse: [ \r\t  element := stream next.\r\t  \"...\" ].\r\r  #readStreamOn: is similar to #executeOn: in that it is a short cut for \r  the longer query form which includes explicit calls to #on:, #optimize \r  and variable binding:\r\r    query := (GsQuery fromString: \'(each.firstName = \'\'Dale\'\')\')\r      on: nsc;\r      optimize.\r    stream := query readStream.\r    [ stream atEnd ] whileFalse: [ \r\t  element := stream next.\r\t  \"...\" ].\r\r  There are similarities between the #do:* and #*readStream* families of\r  evaluation, but I have not yet determined what level of implementation \r  sharing there will be between them. \r\r  Invariance and Queries\r  -------------\r\r  All instances of GsQueryFormula and its subclasses created through the public\r  API are invariant. By making the instances invariant, we are making it safe\r  for query formulas to be persisted and shared without fear that side \r  effects of message sends may change the semantics of the query. \r\r  Given the following formula:\r  \r    (each.age > min) & (each.age < max)\r\r  the optimized form of the query will vary depending upon the value `min` and\r  `max`. If `min=4` and `max=9`:\r\r    (GsQuery fromString: \'(each.age > min) & (each.age < max)\')\r      bind: \'min\' to: 4;\r      bind: \'max\' to: 9;\r      on: nsc;\r      optimize.\r\r  The formula will be optimized to:\r\r    (4 < each.age < 9)\r\r  If the `min=9` and `max=4`:\r\r    (GsQuery fromString: \'(each.age > min) & (each.age < max)\')\r      bind: \'min\' to: 9;\r      bind: \'max\' to: 4;\r      on: nsc;\r      optimize.\r\r  The formula will be optimized to:\r\r    (false)\r\r  as there are no values of `each.age` that can satisfy the query.\r\r  It is important to note that there are no plans to allow the effects of\r  optimizations to be reversed.\r\r  Consequently the form of the formula depends upon which part of the\r  life cycle the formula is accessed. The fact that all formulas are \r  invariant simply means that the following sequence of operations are \r  safe:\r\r    query := GsQuery fromString: \'(each.age > min) & (each.age < max)\'.\r    savedFormula := query formula.\r    query\r      bind: \'min\' to: 9;\r      bind: \'max\' to: 4;\r      on: nsc;\r      optimize.\r    newQuery := GsQuery fromFormula: savedFormula.\r    newQuery\r      bind: \'min\' to: 4;\r      bind: \'max\' to: 9;\r      on: nsc;\r      optimize.\r    anotherFormula := newQuery formula.\r    anotherQuery := anotherFormula asQuery\r    anotherQuery\r      bind: \'min\' to: 3;\r      bind: \'max\' to: 30;\r      on: nsc;\r      optimize.\r    finalQuery := anotherFormula asQuery\r    finalQuery\r      bind: \'min\' to: 30;\r      bind: \'max\' to: 3;\r      on: nsc;\r      optimize.\r\r  Instances of GsQuery are not normally invariant. If one wants to share \r  a query, use the #immediateInvariant message.\r\r  Backwards compatibility with SelectBlock-based queries.\r  -------------\r\r  One may transition to using the GsQuery api while continuing to use \r  SelectBlocks. For example the following four statements:\r\r    | min max |\r    min := 6.\r    max := 55.\r    nsc select: {:each | (each.age > min) & (each.age < max)}.\r    \r    (GsQuery \r      fromSelectBlock: {:each | (each.age > min) & (each.age < max)})\r        executeOn: nsc.\r\r    (GsQuery \r      fromSelectBlock: {:each | (each.age > min) & (each.age < max)}\r      on: nsc) execute.\r\r    (GsQuery fromString: \'(each.age > min) & (each.age < max)\')\r      bind: \'min\' to: min;\r      bind: \'max\' to: max;\r      executeOn: nsc.\r\r  produce exactly the same results. \r\r  Given the mechanism used to extract the query formula from a SelectBlock, \r  it is not possible to alter the variable bindings after the fact as it \r  would be using a query statement. So the following does not work:\r\r    (GsQuery \r      fromSelectBlock: {:each | (each.age > min) & (each.age < max)})\r        bind: \'min\' to: 3;\r        bind: \'max\' to: 9;\r        on: nsc;\r        optimize;\r        execute.\r\r  There are no plans to deprecate the current SelectBlock-based query API \r  (#select:, #detect:, #reject: etc.).\r  \rSet-valued Path Term\r------------------------\r\r  When the indexing code was ported to the 64-bit server, the support for \r  Set-valued path terms was not carried forward. Over time it has become clear\r  that allowing index paths to include collections is a desirable feature, so\r  we will add support for Set-valued path terms in version 3.2.\r\r  An asterisk in the path term of a selection block predicate indicates that a\r  collection is expected at that point in the path:\r\r    GsIndexSpec new\r      equalityIndex: \'each.children.*.age\' lastElementClass: SmallInteger;\r      createIndexesOn: myEmployees.\r    (GsQuery fromString: \'each.children.*.age <= 18\')\r      executeOn: myEmployees.\r\r  The select block sytax will be extended to allow \'*\' in path terms in order\r  to maintain compatibility with existing 32 bit usage:\r\r    myEmployees select: {:each | each.children.*.age <= 18 }\r\r  The query will examine all elements of collection `children`.  In the \r  32-bit server, the collection path terms were restricted to instances of \r  UnorderedCollection. For the 64-bit implementation we will consider defining\r  a set of SAFE collections. Right now, UnorderedCollection is the only member\r  of the SAFE collection set.\r\r  An asterisk my be used in any position in the path.\r\r  If an asterisk is present in the path term when an index is created, changes\r  to the underlying collection will be tracked and the index objects will be\r  automatically updated.\r\rEnumerated Path Term\r------------------------\r\r  An Enumerated Path Term is a list of instance variable names.\r\r  The list of instance variables are specified as a `|` delimited list of \r  instance variable names:\r\r    GsIndexSpec new\r      equalityIndex: \'each.firstName|lastName\' lastElementClass: String;\r      createIndexesOn: myEmployees.\r    (GsQuery fromString: \'each.firstName|lastName = name\')\r      bind: \'name\' to: \'Allen\';\r      executeOn: myEmployees.\r\r  The value of each instance variable listed in the path term will be \r  considered in the query. Changes to either of the instance variables will\r  be tracked and the index objects will be automatically updated.\r\rSelector Path Term\r------------------------\r\r  As another specialization of a Named Path Term (standard PathTerm class), if a\r  Path Term is qualified with the `selector` keyword, the the path term is used\r  as a selector and the result of the message send is to be traversed by the \r  query. The `selector` keyword is denoted by a leading `#` character in the path\r  term:\r\r    GsIndexSpec new\r      equalityIndex: \'each.#car.color\' lastElementClass: String;\r      createIndexesOn: myEmployees.\r    (GsQuery fromString: \'each.#car.color = color\')\r      bind: \'color\' to: \'blue\';\r      executeOn: myEmployees.\r\r  The query will send the message `car` to each element of `myEmployees` and then \r  access the `color` instance variable of the result.\r\r  We cannot automatically maintain dependendencies and update indexes as the \r  elements at that location change, but a user can use the modification tracking \r  api to do this. \r\r  The `selector` qualifier may be used with any named path term position.\r\rHeterogeneous Collections\r------------------------\r\r  The new indexing API supports queries and indexes on heterogenous collections. A\r  heterogenous collection is a collection in which not all members of the collection\r  share the same instance variable structure as defined by the path elements in a \r  query or the path terms in an index specification. \r\r  In earlier versions of the product, when executing a query on a heterogeneous \r  collection, building an index on a heterogeneous collection or adding a \r  heterongeneous object to homogeneous collection; an #rtErrObjectInvalidOffset \r  error was unconditionally signalled upon encountering an instance without the\r  expected named instance variable.\r\r  In 3.2, an #rtErrObjectInvalidOffset error will still be signalled when using the \r  old indexing API for index creation. However, when using the new API the default \r  is to permit indexes on heterogenous collections.\r\r  The #requireAllPathTerms message may be used to enforce the restriction that all \r  queried instances are homogenous with respect to the path terms. Index creation \r  using the #requirePathTerms: keyword may be used to specify that only particular \r  instance variable paths should be homogenous. When a path is specified as \r  requiring path terms, all pathterm on the path are required.\r\r  Here are examples for creating indexes, controlling for the presence of \r  heterogeneous elements in the collection:\r \r    GsIndexSpec new\r      requireAllPathTerms;\r      equalityIndex: \'each.age\' lastElementClass: SmallInteger;\r      equalityIndex: \'each.father.middleName\' lastElementClass: String;\r\t   createIndexesOn: nsc.\r\r    GsIndexSpec new\r      equalityIndex: \'each.age\'\r        lastElementClass: SmallInteger\r        requirePathTerms: false;\r      equalityIndex: \'each.father.middleName\' \r        lastElementClass: String\r        requirePathTerms: true;\r      identityIndex: \'each.father\' \r         requirePathTerms: true;\r\tcreateIndexesOn: nsc.\r\r  Note that in that case where a required path term is a prefix of a\r  heterogeneous path, the required path will be applied to both indexes:\r\r    GsIndexSpec new\r      equalityIndex: \'each.father.middleName\' \r        lastElementClass: String\r        requirePathTerms: false;\r      identityIndex: \'each.father\' \r         requirePathTerms: true;\r\t   createIndexesOn: nsc.\r\r  In the case above the \'father\' instance variable is required and the \r  \'middleName\' instance variable is optional.\r\r  On the other hand, if a required path term wholly encompasses a \r  heterogeneous path, an error will be signalled. The following is an\r  example of this case:\r\r   GsIndexSpec new\r      equalityIndex: \'each.father.middleName\' \r        lastElementClass: String\r        requirePathTerms: true;\r      identityIndex: \'each.father\' \r         requirePathTerms: false;\r      createIndexesOn: nsc.\r\r\rDateTime and DateAndTime\r------------------------\r\r  In both the 32-bit and 64-bit servers, indexes created with a Last Element \r  Class of DateTime or DateAndTime do not use encryption values, thus query\r  operations on instance of the two classes are not as efficient as they \r  could be.\r\r  Martin suggests that both DateTime and DateAndTime should be encrypted by \r  converting the date and time information into signed UTC microseconds since \r  an epoch. The second encryption word with a full SmallInteger range will be \r  used to store the microseconds value. \r\r  For DateTime, UTC microseconds represents the exact value of the `seconds`\r  instance variable, since the resolution for DateTime is in milliseconds.\r\r  The DateAndTime class can use different Number instances to get different\r  levles of resolution (i.e., ScaledDecimal, SmallDouble or Integer) so \r  microseconds may not provide an exact representation.  Therefore the first \r  encrcryption word will have a handful of bytes allocated to indicate whether \r  or not the signed microseconds represents an exact match or is within a \r  microsecond of the exact value.\r\rUnicode String Indexes\r------------------------\r\r  In 3.1 we added support for Unicode strings, but deferred indexing support\r  until a later date ... that date has arrived.\r\r  Unicode string methods take a Unicode collator object (derived from a \r  Locale) to perform primitive string comparison operations. To create an index\r  that uses a Unicode collator the following methods will be used:\r\r    GsIndexSpec new\r      unicodeIndex: \'each.#car.color\' \r        collator: IcuCollator default;\r      rcUnicodeIndex: \'each.firstName\' \r        collator: (IcuCollator forLocaleNamed: \'en_GB\')\r        requireUnicodeStrings: true;\r      createIndexesOn: myEmployees.\r\r  The Unicode collator instance will be made invariant and attached to the \r  index metadata. \r\r  Unicode indexes have an implicit lastElementClass of CharacterCollection.\r  If requireUnicodeStrings: true, then the lastElements must be instance of\r  Unicode string classes: Unicode7, Unicode16, etc.\r\r  It is disallowed to create two Unicode indexes on the same path. Creating\r  a unicode and an equality index on the same path is not explicitly disallowed, \r  but since Unicode strings are disallowed in non-unicode equality indexes, \r  the only way this can succeed is when the index elements are all Strings.\r\r  When a collator is specified while creating a query on a path term upon\r  which an index has been created:\r\r    (GsQuery fromString: \'each.firstName = name\')\r      bind: \'name\' to: \'Allen\';\r      on: myEmployees collator: (IcuCollator forLocaleNamed: \'en_GB\');\r      execute.\r\r  and the collator for the index is #= to the collator specified in the \r  query, then the index will be used to satisfy the query. Otherwise the \r  collator specified in the query will be used for brute force evaluation.\r\r  If no collator is specified for the query, then the collator associated\r  with the index is used to satisfy the query.  For example, given the\r  index created in the above example using IcuCollator default, whatever \r  the default was at the time of index creation, that would be used for \r  the following query:\r\r    (GsQuery fromString: \'each.#car.color = color\')\r      bind: \'color\' to: \'blue\';\r      executeOn: myEmployees.\r\r  For a given Unicode string and a given Unicode collator, a Unicode sort\r  key can be produced. The bytes of the sort key are created such that two\r  sort keys can compared on a byte-wise basis, exactly what is needed for\r  the btree encryption values.\r\rConcurrent Parallel Index Creation\r------------------------\r\r  In 2.x we introduced UnorderedCollection>>createParallelIndexes: which allows\r  one to create a number of indexes on a single collection while making a \r  single pass through the the elements of the collection. \r\r  Norm has suggested that it would be very useful to spread the index creation\r  work across multiple gems. Doing so would only be safe if we can avoid\r  conflicts while updating the structures for each index (the initial creation\r  and final updates are already isolated by the \r  UnorderedCollection>>createParallelIndexes: code).\r\r  Of the index data structures that are created and modified on a per index\r  basis during index creation, only the indexDictionary is shared amongst the \r  various indexes (i.e., each equality index has it\'s own BtreeNode structure).\r  Fortunately, indexDictionary is an RcIndexDictionary, so concurrent updates \r  should be tolerated. \r\r  There are three phases of parallel index creation:\r\r    - create index structures\r    - traverse elements and add index meta data\r    - finalize index structures and update nsc\r\r  The first and third phases need to be run in a single session while the index\r  building can be run concurrently. Here is some sample code illustrating the \r  proposed api:\r\r    | nsc gem1Spec gem2Spec |\r    nsc := Set new.\r    gem1Spec := GsIndexSpec new\r      equalityIndex: \'each.age\' lastElementClass: SmallInteger;\r      yourself.\r    gem2Spec := GsIndexSpec new\r      equalityIndex: \'each.lastName\' lastElementClass: String;\r      yourself.\r    nsc createConcurrentIndexes: gem1Spec, gem2Spec.\r    nsc buildConcurrentIndexes: gem1Spec.\r    nsc buildConcurrentIndexes: gem2Spec.\r    nsc finalizeConcurrentIndexes: gem1Spec, gem2Spec.\r\r  The #buildConcurrentIndexes: would be run in separate concurrent sessions.\r\r  Note: we need to find a way to track index creation progress.\r\rWildcard String Query\r\r  Rather than add additional features to the product at this time, we will \r  instead publish a set of examples documenting the different way that the\r  existing facilities within the image can be used in support of string \r  queries. Examples will include (but not limited to):\r\r    - wildcard string queries: ?xyz, ?xyz*, xyz*\r    - examples of data structures to facilitate word-based queries (i.e., \r      return all documents that contain the word `filetree`)\r\r-------------------------------------------------------------------------------\rAPPENDIX\r-------------------------------------------------------------------------------\r\r64-bit Server Encryption/Decryption\r\r  14 bytes of encryption, 7 bytes in word0 and 7 bytes in word1. The eighth \r  byte in word0 has 5 bits (signed) reserved for type information. There are 5\r  bits that are currently unused in word1.\r\r  The RelCachedValueEType value is offset by -8 to fit in the 5 bit signed \r  integer. 18 types have already been declared (from relops.ht):\r\r  typedef enum {\r    REL_UNDEFINED_CACHE,\r    REL_SYM_CACHE,\r    REL_STR_CACHE,\r    REL_DB_SYM_CACHE,  /* DoubleByteSymbol */\r    REL_DB_STR_CACHE,  /* DoubleByteString */\r    REL_Quad_STR_CACHE,  // QuadByteString\r    REL_Quad_SYM_CACHE,  // future QuadByteSymbol\r    REL_BOOLEAN_CACHE,\r    REL_CHR_CACHE,\r    REL_TIME_CACHE,\r    REL_DATE_CACHE, \r    REL_SMALL_INT_CACHE,\r    REL_LRG_INT_CACHE,\r    REL_ScaledDecimal_CACHE,  /* Gs64 v3.0 ScaledDecimal */\r    // REL_SCALED_DECIMAL_CACHE was not used, same as REL_FRACTION_CACHE,\r    REL_FRACTION_CACHE,\r    REL_SMALL_DBL_CACHE,   /* SmallDouble */\r    REL_FLOAT_CACHE,   /* Float, SmallFloat all encrypted as doubles */\r    REL_DECIMAL_FLOAT_CACHE    /* DecimalFloat */\r    } RelCachedValueEType;\r\r------------------------\rNOTES\r------------------------\r\rSpec Review Comments (Thursday January 17, 2013)\r------------------------\r\r  1. Useful to know if a particular {} block would leverage existing indeses or\r     just end up doing a linear scan. Perhaps #selectIndexed: would throw an\r     error if no index were used.\r\r  2. Alternatives to my suggested PathTerm syntax additions were offered up and\r     deserve more attention.\r\r  3. For Selector Path Term, it was suggested that we may want to introduce a\r     flag in the vm that would allow a developer to detect whether or not a\r     particular message would cause unintended side effects. The issue being\r     that a message used in a selector path term SHOULD NOT have any side\r     effects when executed.\r\r  4. It was suggested that we allow indexing on instances of UTF8.\r\r  5. It was suggested that the Ernie ExternalSession support be moved into the\r     base in order to provide a standard mechanism for doing parallel index\r     creation.\r\r  6. It was suggested that Progress of Index Reporting be made to be consistent\r     and correct.\r\r  7. It was suggested that NamedPathTerm be called AbstractNamedPathTerm.\r\r  8. It was suggested to clarify that the negative `id` discussed in the\r     dependency list entries should be specified as an explicit `-1`.\r\rPathTerm Spec Review (Wednesday February 6, 2013)\r------------------------\r\r  This meeting was held to discuss alternatives that were suggested by\r  Martin[1] and reviewed by Dale and Richard[2].\r\r  [1] martinsStrawManPathTermSyntax.txt\r  [2] daleAndRichardsStrawManPathTermSyntax.txt\r\rIndexed Path Term\r\r  During the discussion related to the syntax for Indexed Path Terms, it was\r  decided that the use case for supporting Indexed Path Terms was marginal at\r  best. As a consequence we are recommending that Indexed Path Terms be dropped\r  from the specification.\r\rCollection-Valued Path Term\r\r  It was decided that if we are to allow the use of the indexable fields in an\r  object for Collection-Valued Path Terms, then we need to restrict their use\r  to SAFE collection classes and NSCs. Examples of SAFE collections are Array\r  and OrderedCollection. UNSAFE collections include Dictionary and RcQueue.\r\rQuery Block, Query API & Optional path terms\r\r  It was decided to construct indexes and queries for Enumerated, Optional, and\r  Selector Path Terms using a Smalltalk API rather than Path Term syntax.\r\r  To support existing 32-bit and 64-bit index creation and queries we will\r  support the old-style path terms and Query Block syntax:\r\r    a.b.c\r    a.*.c\r\r  The API will be expanded to cover optional Named Path Terms and Unicode index\r  creation.\r\rEnumerated Path Term\r\r  Enumerated Path Terms will be restricted to named variables only.\r\rOpen Questions\r\r  1. Is an error signalled by a query using a named path term on an object with\r     no instance variable with the desired name?\r\r  2. Are Set and Bag considered to be NSCs in that they can be the target of an\r     index even though their implementation is vastly different from\r     IdentityBag and friends?\r\rQuery and Index Creation APIs defined (August 2, 2013)\r------------------------\r\r  Between February 10 and the present, a fair amount of work has been done in \r  defining and implenting the Query and Index Creation APIs. \r',#runs:RunArray{#runs:[33197],#values:[[TextColor{#color:Color{#rgb:0}}]],#lastIndex:8124,#lastRun:1,#lastOffset:8123}}},'repo':TDObjectGatewayNode{#name:'repo',#contents:'(TDMonticelloRepository fromDescription: \'filetree:///opt/git/indexing/packages\') repository'},'commitMessage':TDTxtLeafNode{#name:'commitMessage',#contents:Text{#string:'move UnorderedCollection>>_evaluatorFor:isRangeEqualityOperation: back to GemStone-Indexing-Extensions where it belongs',#runs:RunArray{#runs:[74,28,17],#values:[[],[TextColor{#color:Color{#rgb:0}}],[]],#lastIndex:nil,#lastRun:nil,#lastOffset:nil}}},'xx':TDSmalltalkLeafNode{#name:'xx',#contents:'| query nsc expected intersection |\nnsc := IXFamilyTree createFamily population.\nexpected := nsc\n  select: { :each | (1 <= each.numberOfChildren) & (each.numberOfChildren <= 3) }.\nquery := \'(1 <= each.numberOfChildren) & (each.numberOfChildren <= 3)\'\n  asCachedQueryOn: nsc.\nquery size = expected size\n  ifTrue: [ \n    | result |\n    result := query select: [ :each | expected includes: each ].\n    result size = expected size.\n    result := expected select: [ :each | query includes: each ].\n    result size = expected size ]\n  ifFalse: [ false ]'},'analysis':TDTxtLeafNode{#name:'analysis',#contents:Text{#string:'',#runs:RunArray{#runs:[],#values:[],#lastIndex:nil,#lastRun:nil,#lastOffset:nil}}},'browse':TDScriptLeafNode{#name:'browse',#contents:'[ :topez :objIn :tokens :windowId | \n| findTool defs indexSpecDefs indexSpecClassNames |\nfindTool := topez toolInstanceFor: \'find\'.\ndefs := findTool findProjectDefinitions: \'Indexing\'.\nindexSpecDefs := findTool findClassHierarchy: \'AbstractIndexSpecification\'.\r\tindexSpecDefs := indexSpecDefs reject: [:def | def className == #Object].\nindexSpecClassNames := indexSpecDefs collect: [ :def | def className ].\ndefs := defs reject: [ :def | indexSpecClassNames includes: def className ].\ndefs addAll: indexSpecDefs.\nfindTool browseClasses: defs.\ndefs ]'},'todo':TDTxtLeafNode{#name:'todo',#contents:Text{#string:'[x]1. rename GsQueryClause to GsQueryFormula and GsQueryFormula to \r   GsCompoundQueryClause\r[x]2. for a conjunctive clause, the first clause is evaluated using the bindings\r   for the predicates. The second clause should be evaluated against the results of\r   the first clause ... so I need a way to apply a clause against a result nsc ...\r   and ignore the bound evaluator ... or perhaps we can late bind the evaluator \r   during query evaluation?\r3. one should be able to override the default behavior described in 2, to force the\r   native evaluators and rely on set intersection to to resolve the results.\r4. I can imagine an indexed query where instead of maintaining the indexes, an \r   IdentitySet of results is maintained ... so each change to an instance variable \r   causes the result set of the query to be recalculated...so indstead of creating\r   an index on a path, an index on a query is created ... this only works if you \r   have path/constant, constant/path, or path/path predicates ... especially \r   useful for the path/path predicates.\r5. PathEvaluators by their nature will be slower than using a do loop over the \r   collection and applying the query on an element by element basis:\r     - when does the path evaluator make sense?\r       -- when you want to evaluate the query on a predicate by predicate\r          basis ... need to find a use case for this: no indexes but faster...\r          it may turn out that the path evaluators never make sense?\r     - when does it make sense use a do loop? \r       -- whenever the developer determines it\'s faster to apply the entire\r          predicate to each element. \r[x]     - I should be able to evaulate a query in a do loop by passing in each \r       object and resolving all of the terms from that... \r6. For the indexed queries (4), one could index the result set!#$?\r7. A predicate could be bound to a constant nsc ... allowing one to use the nsc as \r   a filter (conjunctive clause) in the query ... disjunctive clauses less \r   interesting\r8. change #null in GsUnaryClause to #noop\r9. the unary constant predicates `false &...`, `false |...`, `true &...`, `true |...` should be further optimized ...\r10. Enumerated and Selector path terms not implemented.\r11. Optional path term implmented for non-indexed query execution only.\r12. requiredPathTerms and unicode indexes not implemented.\r13. Date and DateAndTime index optimization not implemented.\r14. Concurrent parallel index creation not implemented.\r[x]15. #, operation for GsIndexSpec ... concatenate the lists...\r[x]16. replacement for #asCollection\r[x]17. immediate optimize (class creation specify different default optimizer)\r18. delete methods from base:\r    - PathEvaluator>>findAllValuesWithComparison:to:\r    - PathEvaluator>>_findAllValuesWithComparison:to:\r19. Need tests to compare collect: vs asCollection results for each of the \r    operators in path/constant predicates and range predicates ... see\r    IXGsClassicQueryBlockOptimizerTests>>testRemoveRedundant15 for one \r    example ... this is where I saw the initial problem\r20. Remove redundant predicates can be done based on variable names and variable\r    values\r[x]21. repackage to allow parallel work to go on ... either that or fix merge tools',#runs:RunArray{#runs:[93,1,2088,366,1,619,1,82],#values:[[],[TextEmphasis{#emphasisCode:1,#setMode:true}],@152,[TextColor{#color:Color{#rgb:0}}],[@156,TextEmphasis{#emphasisCode:1,#setMode:true}],[@156],[@156,TextEmphasis{#emphasisCode:1,#setMode:true}],@160],#lastIndex:3170,#lastRun:8,#lastOffset:0}}},'filter':TDSmalltalkLeafNode{#name:'filter',#contents:'[ :definition | \ndefinition configurationOf\n  ifNil: [ false ]\n  ifNotNil: [ :configurationDef | configurationDef configurationName = \'Indexing\' ] ]'},'methodCategorization':TDSmalltalkLeafNode{#name:'methodCategorization',#contents:'| block private collection |\nblock := [ :class :selectors :categoryName | \nselectors\n  do: [ :selector | \n    (class includesCategory: categoryName)\n      ifFalse: [ class addCategory: categoryName ].\n    class moveMethod: selector toCategory: categoryName ] ].\nblock\n  value: GsQuery class\n  value: GsQuery class selectors\n  value: \'instance creation\'.\nblock value: GsQuery class value: #(#\'defaultOptimizerClass\') value: \'defaults\'.\nprivate := #(#\'on:\' #\'immediateInvariant\' #\'printOn:\' #\'value:\' #\'optimize\' #\'_nsc:\' #\'optimizeUsing:\' #\'formula:\' #\'hasIndexEvaluators\' #\'_formula:\' #\'formula\' #\'bind:to:\' #\'originalFormula\' #\'_nsc\' #\'requirePathTerms\' #\'withOriginalFormula\' #\'resetCache\' #\'cacheQueryResult:\' #\'cacheQueryResult\' #\'_queryResult\' #\'queryResult\').\nblock value: GsQuery value: private value: \'private\'.\ncollection := #(#\'asIdentityBag\' #\'includes:\' #\'size\' #\'detect:ifNone:\' #\'select:\' #\'reject:\' #\'collect:\' #\'do:\' #\'any\' #\'isEmpty\' #\'detect:\' #\'readStream\' #\'intersection:\' #\'reversedReadStream\' #\'anyIfNone:\' #\'asCollection\').\nblock value: GsQuery value: collection value: \'collection\''},'sample':TDTxtLeafNode{#name:'sample',#contents:Text{#string:'  query := \'((1 <= each.numberOfChildren) not & (each.numberOfChildren <= 3)) not\'\r    asQueryOn: nsc.\r\r  options := query queryOptions.\r  query queryOptions: options - GsQueryOptions autoOptimize.\r\r  query.\r    ((1 <= each.numberOfChildren) not & (each.numberOfChildren <= 3)) not\r  query optimizedFormula.\r    (each.numberOfChildren >= 1) | (each.numberOfChildren > 3)\r  query originalFormula.\r    ((1 <= each.numberOfChildren) not & (each.numberOfChildren <= 3)) not\r  query withOptimizedFormula.\r    (each.numberOfChildren >= 1) | (each.numberOfChildren > 3)\r  query withOriginalFormula.\r    ((1 <= each.numberOfChildren) not & (each.numberOfChildren <= 3)) not\r\r  options := query queryOptions.\r  query queryOptions: options + GsQueryOptions autoOptimize.\r\r  query.\r    (each.numberOfChildren >= 1) | (each.numberOfChildren > 3)\r  query optimizedFormula.\r    (each.numberOfChildren >= 1) | (each.numberOfChildren > 3)\r  query originalFormula.\r    ((1 <= each.numberOfChildren) not & (each.numberOfChildren <= 3)) not\r  query withOptimizedFormula.\r    (each.numberOfChildren >= 1) | (each.numberOfChildren > 3)\r  query withOriginalFormula\r    (each.numberOfChildren >= 1) | (each.numberOfChildren > 3)\r',#runs:RunArray{#runs:[1206],#values:[[TextColor{#color:Color{#rgb:0}}]],#lastIndex:762,#lastRun:1,#lastOffset:761}}},'x':TDSmalltalkLeafNode{#name:'x',#contents:'| query nsc options |\nnsc := IXFamilyTree createFamily population.\nGsQuery\n  fromString:\n    \'((1 <= each.numberOfChildren) not & (each.numberOfChildren <= 3)) not\'\n  on: nsc\n  options: GsQueryOptions default - GsQueryOptions autoOptimize'},'repackage':TDSmalltalkLeafNode{#name:'repackage',#contents:'| family evaluators query tests |\nfamily := TDPackageDefinition new packageName: \'Index-Family\'.\nevaluators := TDPackageDefinition new packageName: \'Index-Evaluators\'.\nquery := TDPackageDefinition new packageName: \'Index-Query\'.\ntests := TDPackageDefinition new packageName: \'Index-Tests\'.\nfamily classDefinitions\n  do: [ :classDef | \n    (classDef isKindOf: TDExtensionClassDefinition)\n      ifTrue: [ \n        classDef instanceMethods , classDef classMethods\n          do: [ :methodDef | \n            ((methodDef className includesString: \'IndexSpecification\')\n              or: [ methodDef className includesString: \'RBParser\' ])\n              ifTrue: [ query pasteTDDefinition: methodDef ]\n              ifFalse: [ \n                ((methodDef className includesString: \'Evaluator\')\n                  or: [ \n                    (methodDef className includesString: \'PathTerm\')\n                      or: [ methodDef className includesString: \'Index\' ] ])\n                  ifTrue: [ evaluators pasteTDDefinition: methodDef ]\n                  ifFalse: [ \n                    ((methodDef className includesString: \'Executer\')\n                      or: [ methodDef className includesString: \'PathTerm\' ])\n                      ifTrue: [ evaluators pasteTDDefinition: methodDef ]\n                      ifFalse: [ evaluators pasteTDDefinition: methodDef ] ] ] ] ]\n      ifFalse: [ \n        ((classDef className beginsWith: \'Gs\')\n          or: [ classDef className beginsWith: \'RB\' ])\n          ifTrue: [ query pasteTDDefinition: classDef ]\n          ifFalse: [ \n            (classDef theClass inheritsFrom: TestCase)\n              ifTrue: [ tests pasteTDDefinition: classDef ]\n              ifFalse: [ \n                (classDef className includesString: \'IndexSpecification\')\n                  ifTrue: [ query pasteTDDefinition: classDef ]\n                  ifFalse: [ \n                    (classDef theClass inheritsFrom: PathEvaluator)\n                      ifTrue: [ evaluators pasteTDDefinition: classDef ] ] ] ] ] ]'}}},'today':TDTxtLeafNode{#name:'today',#contents:Text{#string:'dkh 8/31/2013 07:56\r[x] 1. load Cypress into l_\r[x] 2. save PetitParser work\r 3. Indexing grammar\r 4. responses\r    - Ken tries response\r    - Mark Veigle response\r 5. indexing collection approach\r    - rewrite spec\r    - rewrite implementation\r 6. GLASS\r    - gemstone2.4 and gemstone3.x branches for monticello package\r 7. FileTree\r    - Pharo3.0 port\r 8. Metacello\r    - queued up bugfix\r',#runs:RunArray{#runs:[48,1,48,294],#values:[[TextColor{#color:Color{#rgb:0}}],[@181,TextEmphasis{#emphasisCode:1,#setMode:true}],@180,[]],#lastIndex:98,#lastRun:4,#lastOffset:0}}},'todo':TDTxtLeafNode{#name:'todo',#contents:Text{#string:'------------\r0. \r  - [x]finish Cypress port\r  - [x]glassdb load into l_\r  - [x]load cypress there  \r  - [x]make base changes in glassdb\r  - [x]change the install scripts to load from glassdb ...\r  - [x]cypress diff and save commands\r  - [x]save cypress packages\r  - [x]save PetitParser packages\r0.25 when loading from Cypress repo (not meta data) don\'t supply a user and version\r     need to force loads every time!\r0.35 [x]PetitParser loading with Indexing code\r0.5 check into feasibility of using Cypress instead of Monticello...\r1. indexing spec updates:\r   - enumerated path term\r   - new index scheme\r2. Metacello \r   - bugfix\r   - Chistophe\'s pull request\r   - squeak4.5 issue\r3. glassdb stuff\r   - OB-Monticello\r     undefined symbol error\r   - branch for Monticello versus Monticello.v3\r   - integrate into ConfigurationOfGLASS...\r4. Sebastian Zinc issue.\r5. Cypress ... try out Richards latest\r6. `bu list` should be a TDBackupReport object ... with those fields \r[x]7. import the 3.1.0.4 /home/bin work\r',#runs:RunArray{#runs:[13,8,1,399,1,183,77,331],#values:[[TextColor{#color:Color{#rgb:0}}],[],[TextEmphasis{#emphasisCode:1,#setMode:true}],@194,[TextEmphasis{#emphasisCode:1,#setMode:true}],@194,[TextColor{#color:Color{#rgb:0}}],[]],#lastIndex:464,#lastRun:6,#lastOffset:41}}},'filetree':TDDirectoryNode{#name:'filetree',#contents:{'deploy':TDScriptLeafNode{#name:'deploy',#contents:'^ [ :topez \"This is source for a block.  \" :objIn :tokens :windowId | \n(MCNewFileTreeTodeTool\n  topez: topez\n  objIn: objIn\n  tokens: tokens\n  windowId: windowId) deploy ]'},'gitRepo':TDObjectGatewayNode{#name:'gitRepo',#contents:'| repo |\rrepo := (self topez lookup: \'repo\') dotSelfObject.\rrepo directory containingDirectory'},'doDeploy':TDTopezLeafNode{#name:'doDeploy',#contents:'./deploy 1.0.5 @configRepo http://ss3.gemstone.com/ss/FileTree @repo @commitMessage false'},'notes':TDTxtLeafNode{#name:'notes',#contents:Text{#string:'1.0.5:\r  [x]Issue #11: \r    mostly addressed by Tobias... open new issue for 1.0.6 \r    cherry-pick for pharo3.0 only\r  [x]Issue #92: \r    fix distributed to other platforms \r  [x] #97: \r    fix distributed to other platforms\r  [x]Issue #101:\r    fix distributed to other platforms (needed for clean Issue #11 merge)\r  \r[]pharo13\r[]squeak4.3\r[]pharo11\r[]pharo14\r[]pharo20\r[]pharo30\r[]gemstone24\r',#runs:RunArray{#runs:[228,1,101,1,64],#values:[[],[TextEmphasis{#emphasisCode:1,#setMode:true}],@213,[TextEmphasis{#emphasisCode:1,#setMode:true}],@213],#lastIndex:332,#lastRun:5,#lastOffset:0}}},'commitMessage':TDTxtLeafNode{#name:'commitMessage',#contents:Text{#string:'release 1.0.5:\r\r-fix Issue #11: Traits and Script support\r- fix Issue #92: Mac case insensitivity `must` be addressed\r- fix Issue #97: Load packages from repos with no monticello meta data \r- fix Issue #101: Refactor MCFileTreeStCypressWriter>>writeDefinitions: to ease Issue #11 integration\rfor details: https://github.com/dalehenrich/filetree/issues?direction=desc&milestone=9&page=1&sort=updated&state=closed ',#runs:RunArray{#runs:[16,396],#values:[[],[TextColor{#color:Color{#rgb:536871424}}]],#lastIndex:293,#lastRun:2,#lastOffset:276}}},'configRepo':TDObjectGatewayNode{#name:'configRepo',#contents:'(TDMonticelloRepository\n  fromDescription: \'filetree:///opt/git/configurations/filetree/repository\')\n  repository'},'load':TDTopezLeafNode{#name:'load',#contents:'/home/bin/load FileTree ALL'},'status':TDTxtLeafNode{#name:'status',#contents:'commit 3e59301287f14b7accc9b261d68eca6d57db7456\nAuthor: Dale Henrichs <dhenrich@vmware.com>\nDate:   Sun Aug 11 07:58:47 2013 -0700\n\n    ensure ss3 version is in ancestry\n'},'analysis':TDTxtLeafNode{#name:'analysis',#contents:Text{#string:'deploy  <version> <configRepo> <ss3Repo> <tmpRepo> `commitMessage`',#runs:RunArray{#runs:[66],#values:[[]],#lastIndex:1,#lastRun:1,#lastOffset:0}}},'browse':TDTopezLeafNode{#name:'browse',#contents:'browse project FileTree'},'commit':TDTopezLeafNode{#name:'commit',#contents:'/home/bin/commit FileTree @commitMessage'},'altRepo':TDObjectGatewayNode{#name:'altRepo',#contents:'(TDMonticelloRepository fromDescription: \'http://ss3.gemstone.com/ss/FileTree\')\n  repository'},'tmpRepo':TDObjectGatewayNode{#name:'tmpRepo',#contents:'(TDMonticelloRepository\n  fromDescription: \'filetree:///opt/git/configurations/filetree/repository\')\n  repository'},'diff':TDTopezLeafNode{#name:'diff',#contents:'mm diff FileTree'},'repo':TDObjectGatewayNode{#name:'repo',#contents:'(TDMonticelloRepository fromDescription: \'filetree:///opt/git/gs/filetree/repository\') repository'},'lock':TDSmalltalkLeafNode{#name:'lock',#contents:'Metacello new\n  baseline: \'FileTree\';\n  repository: \'filetree:///opt/git/gs/filetree/repository\';\n  lock'},'filter':TDSmalltalkLeafNode{#name:'filter',#contents:'[ :definition | \ndefinition configurationOf\n  ifNil: [ false ]\n  ifNotNil: [ :configurationDef | configurationDef configurationName = \'FileTree\' ] ]'}}},'bin':TDDirectoryNode{#name:'bin',#contents:{'mapRepos':TDScriptLeafNode{#name:'mapRepos',#contents:'[ :topez :objIn :tokens :windowId | \n| spec version workingCopies mcTool newRepo |\n\"/home/bin/mapRepos Tode filetree:///opt/git/tode/repository\r /home/bin/mapRepos Tode @repo\r\r  ensure that all packages in project have the given repo in repository group.\"\nmcTool := topez toolInstanceFor: \'mc\'.\nnewRepo := mcTool resolveRepositoryReference: (tokens at: 3).\nspec := Metacello image\n  baseline: (tokens at: 2);\n  list.\nversion := spec version.\nworkingCopies := version packages collect: [ :each | each workingCopy ].\nworkingCopies := workingCopies select: [ :each | each notNil ].\nworkingCopies\n  do: [ :wc | \n    | rg |\n    rg := wc repositoryGroup.\n    rg repositories do: [ :repo | rg removeRepository: repo ].\n    rg addRepository: newRepo ] ]'},'commit':TDScriptLeafNode{#name:'commit',#contents:'[ :topez :objIn :tokens :windowId | \n| projectName commitMessage mmTool commitedVersions |\n\"/home/bin/commit Tode `commit message`\r/home/bin/commit Tode @commitMessage\"\nprojectName := tokens at: 2.\ncommitMessage := tokens at: 3.\nmmTool := topez toolInstanceFor: \'mm\'.\n(commitMessage beginsWith: \'@\')\n  ifTrue: [ commitMessage := (mmTool resolveAtPathReference: commitMessage) asString ].\nTranscript\n  cr;\n  show: \'======= committing \' , projectName printString , \'=======\'.\ncommitedVersions := mmTool mmCommit: projectName commitMessage: commitMessage.\ncommitedVersions isEmpty\n  ifTrue: [ \'No dirty packages to commit\' ]\n  ifFalse: [ \n    |  status statusNode gitRepoDir gitTool commitMessageFileName |\n    gitRepoDir := (topez lookup: \'gitRepo\') dotSelfObject.\n    gitTool := topez toolInstanceFor: \'git\'.\n    commitMessageFileName := gitTool createTmpFileWith: commitMessage.\n    gitTool\n      gitaddIn: gitRepoDir with: \'.\';\n      gitstatusIn: gitRepoDir with: \'\';\n      gitcommitIn: gitRepoDir with: \'-a --file=\' , commitMessageFileName;\n      gitstatusIn: gitRepoDir with: \'\'.\n    status := gitTool gitlogIn: gitRepoDir with: \'-1\'.\n    Transcript\n      cr;\n      show: \'==============\'.\n    statusNode := topez\n      lookup: \'status\'\n      ifAbsent: [ \n        topez currentNode\n          addChildNode:\n            (TDTxtLeafNode new\n              name: \'status\';\n              yourself) ].\n    statusNode contents: status.\n    status ] ]'},'create':TDScriptLeafNode{#name:'create',#contents:'[ :topez :objIn :tokens :windowId | \n| directoryName projectName repositoryDescription directoryNode status useConfig useCypress |\n\"/home/bin/create tode Tode filetree:///opt/git/tode/repository [baseline|config|cypress]\"\ndirectoryName := tokens at: 2.\nprojectName := tokens at: 3.\nrepositoryDescription := tokens at: 4.\nuseConfig := false.\nuseCypress := false.\ntokens size > 4\n  ifTrue: [ \n    useConfig := (tokens at: 5) = \'config\'.\n    useCypress := (tokens at: 5) = \'cypress\' ].\ndirectoryNode := topez\n  lookup: directoryName\n  ifAbsent: [ \n    topez currentNode\n      addChildNode:\n        (TDDirectoryNode new\n          name: directoryName;\n          yourself) ].\nuseConfig\n  ifTrue: [ \n    status := \'edit ./load to set correct project version number and load list\'.\n    directoryNode\n      addChildNode:\n          (TDTopezLeafNode new\n              name: \'commit\';\n              contents:\n                  \'/home/bin/commitConfig \' , projectName , \' @commitMessage\';\n              yourself);\n      addChildNode:\n          (TDTopezLeafNode new\n              name: \'load\';\n              contents: \'/home/bin/loadConfig \' , projectName , \' 1.0.0 default\';\n              yourself);\n      yourself ]\n  ifFalse: [ \n    useCypress\n      ifTrue: [ \n    status := \'edit ./load if you don\'\'t want to use default and you are good to go & edit ./cypressRepo\'.\r        directoryNode\n          addChildNode:\n            (TDTopezLeafNode new\n              name: \'commit\';\n              contents:\n                  \'/home/bin/commitCypress \' , projectName , \' @cypressRepo @commitMessage\';\n              yourself) ]\n      ifFalse: [ \n    status := \'edit ./load if you don\'\'t want to use default and you are good to go\'.\r        directoryNode\n          addChildNode:\n            (TDTopezLeafNode new\n              name: \'commit\';\n              contents: \'/home/bin/commit \' , projectName , \' @commitMessage\';\n              yourself) ].\n    directoryNode\n      addChildNode:\n        (TDTopezLeafNode new\n          name: \'load\';\n          contents: \'/home/bin/load \' , projectName , \' default\';\n          yourself) ].\ndirectoryNode\n  addChildNode:\n      (TDTopezLeafNode new\n          name: \'browse\';\n          contents: \'browse project \' , projectName;\n          yourself);\n  addChildNode:\n      (TDTxtLeafNode new\n          name: \'commitMessage\';\n          contents: \'\';\n          yourself).\nuseCypress\n  ifTrue: [ \n    directoryNode\n      addChildNode:\n          (TDTopezLeafNode new\n              name: \'cypressRepo\';\n              contents: \'| repo |\rrepo := CypressFileSystemRepository\r  onUrl:\r    \' , repositoryDescription printString , \' asUrl\r  alias: \' , projectName printString , \'.\rrepo gemStoneFileoutsEnabled: true.\rrepo\';\n              yourself);\n      addChildNode:\n          (TDTopezLeafNode new\n              name: \'diff\';\n              contents: \'cym diff \' , projectName , \' @cypressRepo\';\n              yourself);\n      yourself ]\n  ifFalse: [ \n    directoryNode\n      addChildNode:\n        (TDTopezLeafNode new\n          name: \'diff\';\n          contents: \'mm diff \' , projectName;\n          yourself) ].\ndirectoryNode\n  addChildNode:\n      (TDObjectGatewayNode new\n          name: \'gitRepo\';\n          contents: \'| repo |\rrepo := (self topez lookup: \'\'repo\'\') dotSelfObject.\rrepo directory containingDirectory\';\n          yourself);\n  addChildNode:\n      (TDObjectGatewayNode new\n          name: \'repo\';\n          contents:\n              \'(TDMonticelloRepository fromDescription: \' , repositoryDescription printString\n                  , \') repository\';\n          yourself);\n  addChildNode:\n      (TDTxtLeafNode new\n          name: \'status\';\n          contents: status;\n          yourself);\n  yourself.\nstatus ]'},'primeRegistry':TDSmalltalkLeafNode{#name:'primeRegistry',#contents:'MetacelloProjectRegistration resetRegistry.\t\"reset registry and lock FileTree and Metacello projects\"\nMetacello new\n  baseline: \'FileTree\';\n  repository: \'filetree:///opt/git/gs/filetree/repository\';\n  lock.\nMetacello new\n  baseline: \'Metacello\';\n  repository: \'filetree:///opt/git/metacello-work/repository\';\n  lock.\nMetacelloProjectRegistration primeRegistryFromImage'},'halt':TDSmalltalkLeafNode{#name:'halt',#contents:'\"opportunity to use debugger\"\n| block |\nblock := [:arg | arg halt].\nblock value: 100'},'loadConfig':TDScriptLeafNode{#name:'loadConfig',#contents:'[ :topez :objIn :tokens :windowId | \n| projectName version loads repo description status statusNode |\n\"/home/bin/loadConfig Seaside 3.0.7.1 default\"\nprojectName := tokens at: 2.\nversion := tokens at: 3.\nloads := \'default\'.\ntokens size > 3\n  ifTrue: [ loads := tokens copyFrom: 3 to: tokens size ].\nrepo := (topez lookup: \'repo\') dotSelfObject.\ndescription := repo description.\nMetacello new\n  configuration: projectName;\n  repository: description;\n  get.\nMetacello new\n  configuration: projectName;\n  version: version;\n  repository: description;\n  onConflict: [ :ex | ex allow ];\n  onWarning: [ :ex | \n        Transcript\n          cr;\n          show: \'WARNING: \' , ex description.\n        ex resume ];\n  load: loads.\nstatusNode := topez\n  lookup: \'status\'\n  ifAbsent: [ \n    topez currentNode\n      addChildNode:\n        (TDTxtLeafNode new\n          name: \'status\';\n          yourself) ].\nstatusNode\n  contents:\n    \'Loaded Configuration: \' , projectName printString , \' version \'\n      , version printString , \' from: \' , repo description.\nstatus ]'},'load':TDScriptLeafNode{#name:'load',#contents:'[ :topez :objIn :tokens :windowId | \n| projectName loads repo gitRepo description gitTool status statusNode |\n\"/home/bin/load Tode `GemStone Dev`\"\nprojectName := tokens at: 2.\nloads := \'default\'.\ntokens size > 2\n  ifTrue: [ loads := tokens copyFrom: 3 to: tokens size ].\nrepo := (topez lookup: \'repo\') dotSelfObject.\ndescription := repo description.\nMetacello new\n  baseline: projectName;\n  repository: description;\n  get.\nMetacello new\n  baseline: projectName;\n  repository: description;\n  onConflict: [ :ex | ex allow ];\n  onWarning: [ :ex | \n        Transcript\n          cr;\n          show: \'WARNING: \' , ex description.\n        ex resume ];\n  load: loads.\ngitRepo := (topez lookup: \'gitRepo\') dotSelfObject.\rgitTool := topez toolInstanceFor: \'git\'.\nstatus := gitTool\n  performGitCommand: \'log\'\n  in: gitRepo\n  with: \'-1\'.\nstatusNode := topez\n  lookup: \'status\'\n  ifAbsent: [ \n    topez currentNode\n      addChildNode:\n        (TDTxtLeafNode new\n          name: \'status\';\n          yourself) ].\nstatusNode contents: status.\nstatus ]'},'commitConfig':TDScriptLeafNode{#name:'commitConfig',#contents:'[ :topez :objIn :tokens :windowId | \n| projectName commitMessage mmTool commitedVersions |\n\"/home/bin/commitConfig Seaside30 `commit message`\r/home/bin/commitConfig Seaside30 @commitMessage\"\nprojectName := tokens at: 2.\ncommitMessage := tokens at: 3.\nmmTool := topez toolInstanceFor: \'mm\'.\n(commitMessage beginsWith: \'@\')\n  ifTrue: [ commitMessage := (mmTool resolveAtPathReference: commitMessage) asString ].\nTranscript\n  cr;\n  show: \'======= committing \' , projectName printString , \'=======\'.\ncommitedVersions := mmTool mmCommit: projectName commitMessage: commitMessage.\ncommitedVersions isEmpty\n  ifTrue: [ \'No dirty packages to commit\' ]\n  ifFalse: [ \n    | statusNode status version projectSpec |\n    projectSpec := Metacello image\n      project: projectName;\n      list.\n    MetacelloToolBox\n      updateDevelopment: projectSpec versionString\n      for: projectName\n      updatePackages: true\n      description: commitMessage.\r\tstatus := \'Committed Configuration: \' , projectName printString , \' version \'\r      , version printString , \' \' , commitMessage printString.\n    Transcript\n      cr;\n      show: \'==============\'.\n    statusNode := topez\n      lookup: \'status\'\n      ifAbsent: [ \n        topez currentNode\n          addChildNode:\n            (TDTxtLeafNode new\n              name: \'status\';\n              yourself) ].\n    statusNode contents: status.\n    status ] ]'},'import':TDScriptLeafNode{#name:'import',#contents:'[ :topez :objIn :tokens :windowId | \n| stonTool |\nstonTool := topez toolInstanceFor: \'ston\'.\nstonTool\n  stonImportFrom: \'/opt/git/tode/ston/home.ston\' to: (topez lookup: \'/\');\n  stonImportFrom: \'/opt/git/tode/ston/bin.ston\' to: (topez lookup: \'/home\').\ntopez setCurrentNode: (topez lookup: \'/home\') ]'},'export':TDScriptLeafNode{#name:'export',#contents:'[ :topez :objIn :tokens :windowId | \n| stonTool |\nstonTool := topez toolInstanceFor: \'ston\'.\nstonTool\n  stonExportNode: (topez lookup: \'/home\') to: \'/opt/git/tode/ston/home.ston\';\n  stonExportNode: (topez lookup: \'/home/bin\') to: \'/opt/git/tode/ston/bin.ston\' ]'},'commitCypress':TDScriptLeafNode{#name:'commitCypress',#contents:'[ :topez :objIn :tokens :windowId | \n| projectName commitMessage cypressTool cypressRepo gitRepoDir gitTool status statusNode commitMessageFileName |\n\"/home/bin/commitCypress Cypress  @cypressRepo @commitMessage\"\ncypressTool := topez toolInstanceFor: \'cym\'.\nprojectName := tokens at: 2.\ncypressRepo := cypressTool resolveAtPathReference: (tokens at: 3).\ncommitMessage := (cypressTool resolveAtPathReference: (tokens at: 4)) asString.\nTranscript\n  cr;\n  show: \'======= committing \' , projectName printString , \'=======\'.\ncypressTool cymSave: projectName to: cypressRepo.\ngitRepoDir := (topez lookup: \'gitRepo\') dotSelfObject.\ngitTool := topez toolInstanceFor: \'git\'.\ncommitMessageFileName := gitTool createTmpFileWith: commitMessage.\ngitTool\n  gitaddIn: gitRepoDir with: \'.\';\n  gitstatusIn: gitRepoDir with: \'\';\n  gitcommitIn: gitRepoDir with: \'-a --file=\' , commitMessageFileName;\n  gitstatusIn: gitRepoDir with: \'\'.\nstatus := gitTool gitlogIn: gitRepoDir with: \'-1\'.\nTranscript\n  cr;\n  show: \'==============\'.\nstatusNode := topez\n  lookup: \'status\'\n  ifAbsent: [ \n    topez currentNode\n      addChildNode:\n        (TDTxtLeafNode new\n          name: \'status\';\n          yourself) ].\nstatusNode contents: status.\nstatus ]'}}},'metacello':TDDirectoryNode{#name:'metacello',#contents:{'gitRepo':TDObjectGatewayNode{#name:'gitRepo',#contents:'| repo |\rrepo := (self topez lookup: \'repo\') dotSelfObject.\rrepo directory containingDirectory'},'commit':TDTopezLeafNode{#name:'commit',#contents:'/home/bin/commit Metacello @commitMessage'},'commitMessage':TDTxtLeafNode{#name:'commitMessage',#contents:Text{#string:'add Metacello-Cypress package with Metacello support for using a baseline with a pure Cypress repository. \r\rDefine #projectClass method to return: MetacelloCypressBaselineProject. \rAdvantage is that when you load baseline from a cypress repository, there is no monticello meta data, so there is no version to compare with the image ... we want to unconditionally load all of the packages and let the loader sort things out ..\r',#runs:RunArray{#runs:[4,17,95,12,298],#values:[[],[TextColor{#color:Color{#rgb:1023}}],[],[TextColor{#color:Color{#rgb:0}}],[TextColor{#color:Color{#rgb:512}}]],#lastIndex:nil,#lastRun:nil,#lastOffset:nil}}},'load':TDTopezLeafNode{#name:'load',#contents:'/home/bin/load Metacello ALL'},'status':TDTxtLeafNode{#name:'status',#contents:'commit c304ff7380d9e6aab9a9611351a4abcbcdfc37dc\nAuthor: Dale Henrichs <dale.henrichs@gemtalksystems.com>\nDate:   Sun Sep 1 00:21:46 2013 -0700\n\n    add Metacello-Cypress package with Metacello support for using a baseline with a pure Cypress repository.\n    \n    Define #projectClass method to return: MetacelloCypressBaselineProject.\n    Advantage is that when you load baseline from a cypress repository, there is no monticello meta data, so there is no version to compare with the image ... we want to unconditionally load all of the packages and let the loader sort things out ..\n'},'diff':TDTopezLeafNode{#name:'diff',#contents:'mm diff Metacello'},'browse':TDTopezLeafNode{#name:'browse',#contents:'browse project Metacello'},'repo':TDObjectGatewayNode{#name:'repo',#contents:'(TDMonticelloRepository fromDescription: \'filetree:///opt/git/metacello-work/repository\') repository'},'browseSpecs':TDTopezLeafNode{#name:'browseSpecs',#contents:'browse hierarchy MetacelloSpec'}}},'rb':TDDirectoryNode{#name:'rb',#contents:{'gitRepo':TDObjectGatewayNode{#name:'gitRepo',#contents:'| repo |\rrepo := (self topez lookup: \'repo\') dotSelfObject.\rrepo directory containingDirectory'},'repo':TDObjectGatewayNode{#name:'repo',#contents:'(TDMonticelloRepository fromDescription: \'filetree:///opt/git/rb/repository\') repository'},'commit':TDTopezLeafNode{#name:'commit',#contents:'/home/bin/commit RB @commitMessage'},'commitMessage':TDTxtLeafNode{#name:'commitMessage',#contents:''},'browse':TDTopezLeafNode{#name:'browse',#contents:'browse project RB'},'diff':TDTopezLeafNode{#name:'diff',#contents:'mm diff RB'},'load':TDTopezLeafNode{#name:'load',#contents:'/home/bin/load RB default'},'status':TDTxtLeafNode{#name:'status',#contents:'edit ./load if you don\'t want to use default and you are good to go'}}},'glass':TDDirectoryNode{#name:'glass',#contents:{'gitRepo':TDObjectGatewayNode{#name:'gitRepo',#contents:'| repo |\rrepo := (self topez lookup: \'repo\') dotSelfObject.\rrepo directory containingDirectory'},'repo':TDObjectGatewayNode{#name:'repo',#contents:'(TDMonticelloRepository fromDescription: \'filetree:///opt/git/glass/repository\') repository'},'commit':TDTopezLeafNode{#name:'commit',#contents:'/home/bin/commit GLASS1 @commitMessage'},'commitMessage':TDTxtLeafNode{#name:'commitMessage',#contents:Text{#string:'Character>>sameAs: belongs here',#runs:RunArray{#runs:[18,13],#values:[[TextColor{#color:Color{#rgb:0}}],[]],#lastIndex:nil,#lastRun:nil,#lastOffset:nil}}},'browse':TDTopezLeafNode{#name:'browse',#contents:'browse project GLASS1'},'diff':TDTopezLeafNode{#name:'diff',#contents:'mm diff GLASS1'},'load':TDTopezLeafNode{#name:'load',#contents:'/home/bin/load GLASS1 default'},'status':TDTxtLeafNode{#name:'status',#contents:'commit 52f5d2fa6e3f84318f85d89f220f052404d93241\nAuthor: Dale Henrichs <dale.henrichs@gemtalksystems.com>\nDate:   Sat Aug 31 16:12:16 2013 -0700\n\n    Character>>sameAs: belongs here\n'}}},'x':TDSmalltalkLeafNode{#name:'x',#contents:'| repo |\nrepo := MCGitHubRepository\n  location: \'github://glassdb/zinc:gemstone3.1/repository\''}}}